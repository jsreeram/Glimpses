<html>
<head><title>Dynamic Call Graph </title></head>
<body>
<center><h2>Dynamic Call Graph </h2></center>
<br/>     
   This graph consists of all the functions that were called during the
   profile-run. There is one node for each instance when the function was called.
   They are time-stamped to indicate the order in which they were called.
   
<br/>The following actions can be done on both tabs
<ul>
       <li> Right click to fit the entire graph in the window
       <li> Use the scroll wheel to zoom in into the graph
       <li> Click on function nodes and drag them to move the whole graph.
       <li> Click on an empty area in this pane and drag to move the entire graph.

</ul>
<br/>
  For example, if we have a workload consisting of functions as follows
 
<br/>
<br/>  A()
<br/> {
<br/>       cout<<"In A";
<br/>  }  
<br/>  B(int x) 
<br/>  {
<br/>       if(x==5)
<br/>  {
<br/>	  A();
<br/>       }
<br/>  }	
<br/>
<br/>  int main()
<br/>  {
<br/>       B(5);
<br/>      B(0);
<br/>  }

<br/>  For the above function:
<br/>  The dynamic call graph 
<br/>		
<br/>      main.0--> B.1 -->A.2
<br/>	    |
<br/> 	    V	
<br/>	   B.3                    ---> the suffixes indicate the sequence of calls, and we notice that 
<br/>				    B.1 is distinguised from B.3	
 
<br/>   The static call graph would be

<br/>      main--> B --> A		---> one node for each function, without separating calling contexts.
				    since all functions were called atleast once in the profile run, they
				    would all be colored green.


<br/>   Actions allowed in the Dynamic Call Graph:
<ul>
<li>
       Hover over a node to see update information in the Function properties panel
       (Memory Map, Function Characteristics)
</ul>       

</body>
</html>

